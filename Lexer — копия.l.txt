%{
#include "Parser.tab.h" 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_STRING_LENGTH 1024
#define MAX_COMMENT_LENGTH 4096

void print_token(const char* type, const char* value) {
    printf("%s: %s\n", type, value);
}

void reset_string(char* str, int* index) {
    str[0] = '\0';
    *index = 0;
}

void append_char(char* str, int* index, char c) {
    if (*index < MAX_STRING_LENGTH - 1) {
        str[(*index)++] = c;
        str[*index] = '\0';
    }
}

void append_string(char* str, int* index, const char* src) {
    int len = strlen(src);
    if (*index + len < MAX_STRING_LENGTH - 1) {
        strcpy(str + *index, src);
        *index += len;
    }
}

%}

%option noyywrap
%option never-interactive
%option yylineno

DIGIT    [0-9]
ID       [a-zA-Z_][a-zA-Z0-9_]*
FSUFFIX  [fF]
DSUFFIX  [dD]
MSUFFIX  [mM]

%x MULTILINE_COMMENT
%x STRING_LITERAL
%x VERBATIM_STRING_LITERAL
%x CHARACTER_LITERAL

%%
%{
char currentStringLiteral[MAX_STRING_LENGTH];
char currentComment[MAX_COMMENT_LENGTH];
char currentCharacter[10];
int currentInteger;
double currentFloatingPoint;
char buffer[10];
int currentStringIndex = 0;
int currentCommentIndex = 0;
int currentCharIndex = 0;
%}

"/*"                                    {
                                            reset_string(currentComment, &currentCommentIndex);
                                            BEGIN(MULTILINE_COMMENT);
                                        }

<MULTILINE_COMMENT>[^*\n]+              {append_string(currentComment, &currentCommentIndex, yytext);}

<MULTILINE_COMMENT>\*[^/\n]             {append_string(currentComment, &currentCommentIndex, yytext);}

<MULTILINE_COMMENT>\*+$                 {append_string(currentComment, &currentCommentIndex, yytext);}

<MULTILINE_COMMENT>\n                   {append_string(currentComment, &currentCommentIndex, yytext);}

<MULTILINE_COMMENT>\*+\/                {
                                            printf("MULTILINE_COMMENT: %s\n", currentComment);
                                            BEGIN(INITIAL);
                                        }

<MULTILINE_COMMENT><<EOF>>              {
                                            printf("Error! Expected end of multiline comment but found end of file! Line: %d\n", yylineno);
                                            BEGIN(INITIAL);
                                        }
                                        
\/\/.*                                  { printf("Found single-line comment: %s\n", yytext);}

\"                                      {
                                            reset_string(currentStringLiteral, &currentStringIndex);
                                            BEGIN(STRING_LITERAL);
                                        }

<STRING_LITERAL>[^\\\"\n]+              { append_string(currentStringLiteral, &currentStringIndex, yytext);}

<STRING_LITERAL>\\x[0-9a-fA-F]{1,4}     {
                                            memset(buffer, 0, sizeof(buffer));
                                            strncpy(buffer, yytext, yyleng);
                                            sscanf(buffer + 2, "%x", &currentInteger);
                                            append_char(currentStringLiteral, &currentStringIndex, (char)currentInteger);
                                        }

<STRING_LITERAL>\\n                     { append_char(currentStringLiteral, &currentStringIndex, '\n');}

<STRING_LITERAL>\\t                     { append_char(currentStringLiteral, &currentStringIndex, '\t');}

<STRING_LITERAL>\\a                     { append_char(currentStringLiteral, &currentStringIndex, '\a');}

<STRING_LITERAL>\\b                     { append_char(currentStringLiteral, &currentStringIndex, '\b');}

<STRING_LITERAL>\\f                     { append_char(currentStringLiteral, &currentStringIndex, '\f');}

<STRING_LITERAL>\n                      { printf("Error! Unterminated string literal at line: %d\n", yylineno); BEGIN(INITIAL);}

<STRING_LITERAL><<EOF>>                 { printf("Error! Unterminated string literal at line: %d\n", yylineno); BEGIN(INITIAL);}

<STRING_LITERAL>\\r                     { append_char(currentStringLiteral, &currentStringIndex, '\r');}

<STRING_LITERAL>\\v                     { append_char(currentStringLiteral, &currentStringIndex, '\v');}

<STRING_LITERAL>\\0                     { append_char(currentStringLiteral, &currentStringIndex, '\0');}

<STRING_LITERAL>\\\\                    { append_char(currentStringLiteral, &currentStringIndex, '\\');}

<STRING_LITERAL>\\\"                    { append_char(currentStringLiteral, &currentStringIndex, '\"');}

<STRING_LITERAL>\\\'                    { append_char(currentStringLiteral, &currentStringIndex, '\'');}

<STRING_LITERAL>\" {
    yylval.string_value = strdup(currentStringLiteral);
    BEGIN(INITIAL);
    return STRING_LITERAL;
}

<STRING_LITERAL>\\.                     { printf("Error escape sequence in string: %s\n", currentStringLiteral);}

@\"                                     { reset_string(currentStringLiteral, &currentStringIndex); BEGIN(VERBATIM_STRING_LITERAL); }

<VERBATIM_STRING_LITERAL>\"\"           { append_char(currentStringLiteral, &currentStringIndex, '\"');}

<VERBATIM_STRING_LITERAL>[^"\n]+        { append_string(currentStringLiteral, &currentStringIndex, yytext);}

<VERBATIM_STRING_LITERAL>\n             { append_char(currentStringLiteral, &currentStringIndex, '\n');}

<VERBATIM_STRING_LITERAL>\" { 
    yylval.string_value = strdup(currentStringLiteral);
    BEGIN(INITIAL);
    return STRING_LITERAL;
}

<VERBATIM_STRING_LITERAL><<EOF>>        { printf("Error! Unterminated verbatim string literal at line: %d\n", yylineno); BEGIN(INITIAL);}

\'                                      { reset_string(currentCharacter, &currentCharIndex); BEGIN(CHARACTER_LITERAL);}

<CHARACTER_LITERAL>\'                   {
                                            if (strlen(currentCharacter) == 0) 
                                            {
                                                printf("Error! Found empty character literal\n");
                                            }
                                            else if (strlen(currentCharacter) > 1)
                                            {
                                                printf("Error! Character literal is not allowed to have more than one character\n");
                                            }
    					    else {
						yylval.char_value = currentCharacter[0];
        					BEGIN(INITIAL);
        					return CHAR_LITERAL;
    					    }
                                            BEGIN(INITIAL);
                                        }

<CHARACTER_LITERAL>[^\'\\]+             { append_string(currentCharacter, &currentCharIndex, yytext);}

<CHARACTER_LITERAL>\\x[0-9a-fA-F]{1,4}  {
                                            memset(buffer, 0, sizeof(buffer));
                                            strncpy(buffer, yytext + 2, yyleng - 2);
                                            sscanf(buffer, "%x", &currentInteger);
                                            append_char(currentCharacter, &currentCharIndex, (char)currentInteger);
                                        }

<CHARACTER_LITERAL>\\n                  { append_char(currentCharacter, &currentCharIndex, '\n');}

<CHARACTER_LITERAL>\\t                  { append_char(currentCharacter, &currentCharIndex, '\t');}

<CHARACTER_LITERAL>\\a                  { append_char(currentCharacter, &currentCharIndex, '\a');}

<CHARACTER_LITERAL>\\b                  { append_char(currentCharacter, &currentCharIndex, '\b');}

<CHARACTER_LITERAL>\\f                  { append_char(currentCharacter, &currentCharIndex, '\f');}

<CHARACTER_LITERAL>\\r                  { append_char(currentCharacter, &currentCharIndex, '\r');}

<CHARACTER_LITERAL>\\v                  { append_char(currentCharacter, &currentCharIndex, '\v');}

<CHARACTER_LITERAL>\\?                  { append_char(currentCharacter, &currentCharIndex, '\?');}

<CHARACTER_LITERAL>\\0                  { append_char(currentCharacter, &currentCharIndex, '\0');}

<CHARACTER_LITERAL>\\\\                 { append_char(currentCharacter, &currentCharIndex, '\\');}

<CHARACTER_LITERAL>\\\"                 { append_char(currentCharacter, &currentCharIndex, '\"');}

<CHARACTER_LITERAL>\\\'                 { append_char(currentCharacter, &currentCharIndex, '\'');}



char                                    { return CHAR_TYPE; }
int                                     { return INT_TYPE;}
void                                    { return VOID_TYPE;}
string                                  { return STRING_TYPE;}
var                  			{ return VAR_TYPE; }

out                                     { return OUT;}
ref                                     { return REF;}


namespace                               { return NAMESPACE;}
using                                   { return USING; }


public                 { return PUBLIC; }
protected              { return PROTECTED; }
private                { return PRIVATE;}
internal               { return INTERNAL;}

struct               { return STRUCT;}
class                { return CLASS;}
static               { return STATIC;}
enum                 { return ENUM; }
interface            { return INTERFACE; }
abstract             { return ABSTRACT; }
sealed               { return SEALED; }
virtual              { return VIRTUAL;}
override             { return OVERRIDE;}
new                  { return NEW; }
this                 { return THIS; }
base                 { return BASE; }

for                  { return FOR; }
foreach              { return FOREACH; }
while                { return WHILE; }
do                   { return DO; }
continue             { return CONTINUE; }
if                   { return IF; }
else                 { return ELSE; }
switch               { return SWITCH; }
case                 { return CASE; }
default              { return DEFAULT; }
break                { return BREAK; }
return               { return RETURN; }
goto                 { return GOTO; }

float                { return FLOAT_TYPE; }
double               { return DOUBLE_TYPE; }
decimal              { return DECIMAL_TYPE; }
bool                 { return BOOL_TYPE; }
true                 { yylval.bool_value = 1; return BOOL_LITERAL_TRUE; }
false                { yylval.bool_value = 0; return BOOL_LITERAL_FALSE; }

"&&"                 { return AND; }
"||"                 { return OR; }
"!"                  { return '!'; }
"&"                  { return '&'; }
"|"                  { return '|'; }
"~"                  { return '~'; }

"["                  { return '['; }
"]"                  { return ']'; }
","                  { return ','; }


{DIGIT}+\.{DIGIT}*({FSUFFIX}|{DSUFFIX}|{MSUFFIX})? {
    char* input_text = strdup(yytext);
    int length = strlen(input_text);
    char last_char = input_text[length - 1];

    if (last_char == 'f' || last_char == 'F'){
        input_text[length - 1] = '\0';
        yylval.float_value = strtof(input_text, NULL);
        free(input_text);
        return FLOAT_LITERAL;
    } else if (last_char == 'm' || last_char == 'M'){
        input_text[length - 1] = '\0';
        yylval.double_value = strtod(input_text, NULL);
        free(input_text);
        return DECIMAL_LITERAL;
    } else {
        yylval.double_value = strtod(input_text, NULL);
        free(input_text);
        return DOUBLE_LITERAL;
    }
}



{DIGIT}+ {
    yylval.int_value = atoi(yytext); 
    return INTEGER_LITERAL;
}

{DIGIT}+(_+{DIGIT}+)+ {
    char cleaned[256];
    int j = 0;
    for (int i = 0; yytext[i] != '\0' && j < 255; i++) {
        if (yytext[i] != '_') cleaned[j++] = yytext[i];
    }
    cleaned[j] = '\0';
    yylval.int_value = atoi(cleaned); 
    return INTEGER_LITERAL;
}

"++"       { return PLUSPLUS; }  
"+"       { return '+'; }
"--"       { return MINUSMINUS; }  
"-"       { return '-'; }
"*"       { return '*'; }
"/"       { return '/'; }
"%"       { return '%'; }

"=="      { return EQUAL; }
"!="      { return NOT_EQUAL; }
"<"       { return '<'; }
">"       { return '>'; }
"<="      { return LESS_EQUAL; }
">="      { return GREATER_EQUAL; }

"="       { return '='; }
"+="      { return PLUS_ASSIGNMENT; }
"-="      { return MINUS_ASSIGNMENT; }
"*="      { return MUL_ASSIGNMENT; }
"/="      { return DIV_ASSIGNMENT; }
"%="      { return MOD_ASSIGNMENT; }  
"|="      { return OR_ASSIGNMENT; }   


"."       { return '.'; }
";"       { return ';'; }
":"       { return ':'; }
"?"       { return '?'; }
"??"      { return NULL_COALESCE; }   
"::"      { return SCOPE; }  
"("       { return '('; }
")"       { return ')'; }
"{"       { return '{'; }
"}"       { return '}'; }

{ID}      { yylval.string_value = strdup(yytext); return IDENTIFIER; }
[ \t\r\n]+    ;

.         { print_token("UNKNOWN_CHAR", yytext); }

%%